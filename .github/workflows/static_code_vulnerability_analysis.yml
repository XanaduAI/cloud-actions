# See ./static_code_vulnerability_analysis.md for documentation

name: Analyse Source Code for Security Vulnerabilities

on:
  workflow_call:
    inputs:
      github-repository:
        description: 'The GitHub Repository to scan'
        type: string
        required: true
      repository-ref:
        description: 'The branch or tag to scan'
        type: string
        required: true
      runner_name:
        description: 'The name of the runner to use'
        type: string
        required: false
        default: 'ubuntu-latest'
      
      scan_directory:
        description: 'The directory to scan within the cloned repository. By default, the root directory of cloned repo is scanned (recursively).'
        type: string
        required: false
        default: './'
      
      enable-bandit-scan:
        description: 'Enable Bandit Scan'
        type: boolean
        required: false
        default: true
      enable-semgrep-scan:
        description: 'Enable Semgrep Scan'
        type: boolean
        required: false
        default: true
      
      bandit-config-file:
        description: 'Location of Bandit Config File within the repository that is cloned'
        type: string
        required: false
        default: ''
      bandit-error-on-severity:
        description: 'Bandit Error on Severity. If bandit raises an error of at least this severity, the job will fail.'
        type: string
        required: false
        default: 'LOW'  # LOW, MEDIUM, HIGH
      bandit-additional-args:
        description: 'Additional arguments to pass to Bandit'
        type: string
        required: false
        default: ''
      bandit-upload-json-report:
        description: 'Upload Bandit JSON Report'
        type: boolean
        required: false
        default: false
    
      semgrep-rules-file:
        description: 'File name containing rules for Semgrep. Defaults to `auto` which pulls OSS rules from semgrep registry'
        type: string
        required: false
        default: 'auto'
      semgrep-error-on-impact:
        description: 'Semgrep Error on Impact. If semgrep raises an error of at least this impact, the job will fail.'
        type: string
        required: false
        default: 'LOW'  # LOW, MEDIUM, HIGH
      semgrep-error-on-severity:
        description: 'Semgrep Error on Severity. If semgrep raises an error of at least this severity, the job will fail.'
        type: string
        required: false
        default: 'WARNING'  # WARNING, ERROR, CRITICAL
      semgrep-additional-args:
        description: 'Additional arguments to pass to Semgrep'
        type: string
        required: false
        default: ''
      semgrep-upload-json-report:
        description: 'Upload Semgrep JSON Report'
        type: boolean
        required: false
        default: false

jobs:
  semgrep:
    runs-on: ${{ inputs.runner_name }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          repository: ${{ inputs.github-repository }}
          ref: ${{ inputs.repository-ref }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install Semgrep
        shell: bash
        run: pip install semgrep
      
      - name: Run Semgrep Scan
        shell: bash
        env:
          SEMGREP_SCAN_DIR: ${{ inputs.scan_directory }}
        run: |
          semgrep scan --config ${{ inputs.semgrep-rules-file }} --json --json-output semgrep_report.json --quiet ${{ inputs.semgrep-additional-args }} "$SEMGREP_SCAN_DIR" > /dev/null || true

          # Also run with normal output for display purposes
          semgrep scan --config ${{ inputs.semgrep-rules-file }} ${{ inputs.semgrep-additional-args }} "$SEMGREP_SCAN_DIR" || true
      
      - name: Filter Semgrep Scan Results
        id: semgrep-filter
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const fs = require('fs');
            
            try {
              const semgrep_report = JSON.parse(fs.readFileSync('semgrep_report.json', 'utf8'));
              
              // Mapping for impact thresholds
              const impactThresholdMap = {
                'LOW': ['LOW', 'MEDIUM', 'HIGH'],
                'MEDIUM': ['MEDIUM', 'HIGH'],
                'HIGH': ['HIGH']
              };
              
              // Mapping for severity thresholds
              const severityThresholdMap = {
                'WARNING': ['WARNING', 'ERROR', 'CRITICAL'],
                'ERROR': ['ERROR', 'CRITICAL'],
                'CRITICAL': ['CRITICAL']
              };
              
              // Get the threshold lists
              const impactThresholds = impactThresholdMap['${{ inputs.semgrep-error-on-impact }}'] || ['LOW', 'MEDIUM', 'HIGH'];
              const severityThresholds = severityThresholdMap['${{ inputs.semgrep-error-on-severity }}'] || ['WARNING', 'ERROR', 'CRITICAL'];
              
              console.log(`Filtering for impacts: ${impactThresholds.join(', ')}`);
              console.log(`Filtering for severities: ${severityThresholds.join(', ')}`);
              
              // Filter results based on both impact level and severity
              let filtered_report = [];
              
              if (semgrep_report.results) {
                filtered_report = semgrep_report.results.filter(result => {
                  // Extract the impact from metadata if available
                  const impact = result.extra?.metadata?.impact || 'MEDIUM';
                  // Extract the severity directly from the result
                  const severity = result.extra?.severity || 'WARNING';
                  
                  // A finding must meet BOTH the impact AND severity thresholds
                  const meetsImpactThreshold = impactThresholds.includes(impact);
                  const meetsSeverityThreshold = severityThresholds.includes(severity);
                  
                  return meetsImpactThreshold && meetsSeverityThreshold;
                });
              }
              
              console.log(`Found ${filtered_report.length} Semgrep issues meeting both impact and severity thresholds`);
              
              // Log the specific issues for visibility
              if (filtered_report.length > 0) {
                console.log("Found issues:");
                filtered_report.forEach((issue, idx) => {
                  const path = issue.path;
                  const line = issue.start?.line || 'N/A';
                  const message = issue.extra?.message || 'No message provided';
                  const impact = issue.extra?.metadata?.impact || 'UNKNOWN';
                  const severity = issue.extra?.severity || 'UNKNOWN';
                  
                  console.log(`#${idx+1}: ${path}:${line} - ${message} (Impact: ${impact}, Severity: ${severity})`);
                });
              }
              
              fs.writeFileSync('semgrep_filtered_report.json', JSON.stringify(filtered_report));
              
              return filtered_report.length > 0 ? 'true' : 'false';
            } catch (error) {
              console.log('Error processing Semgrep report:', error);
              return 'false';
            }
      
      - name: Upload semgrep raw JSON Report
        if: inputs.semgrep-upload-json-report == true
        uses: actions/upload-artifact@v4
        with:
          name: semgrep_raw_report
          path: semgrep_report.json
      
      - name: Upload semgrep filtered JSON Report
        if: steps.semgrep-filter.outputs.result == 'true' && inputs.semgrep-upload-json-report == true
        uses: actions/upload-artifact@v4
        with:
          name: semgrep_filtered_report

      - name: Error if Semgrep Scan Results
        if: steps.semgrep-filter.outputs.result == 'true'
        shell: bash
        run: exit 1
  
  bandit:
    runs-on: ${{ inputs.runner_name }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          repository: ${{ inputs.github-repository }}
          ref: ${{ inputs.repository-ref }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install Bandit
        shell: bash
        run: pip install 'bandit[sarif,toml]'
        
      - name: Bandit Args
        id: bandit-config-args
        run: |
          if [ -n "${{ inputs.bandit-config-file }}" ]; then
            echo "config=-c ${{ inputs.bandit-config-file }}" >> $GITHUB_OUTPUT
          fi
        
      - name: Run Bandit Scan
        shell: bash
        env:
          BANDIT_SCAN_DIR: ${{ inputs.scan_directory }}
        run: |
          bandit ${{ steps.bandit-config-args.outputs.config }} -f json -o bandit_report.json -r ${{ inputs.bandit-additional-args }} "$BANDIT_SCAN_DIR" || true 

          # Scan again, to show output to screen
          bandit ${{ steps.bandit-config-args.outputs.config }} -f screen -r ${{ inputs.bandit-additional-args }} "$BANDIT_SCAN_DIR" || true 
      
      - name: Filter Bandit Scan Results
        id: bandit-filter
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const fs = require('fs');
            
            try {
              const bandit_report = JSON.parse(fs.readFileSync('bandit_report.json', 'utf8'));
              
              // Define severity levels and their hierarchy
              const severityLevels = {
                'LOW': ['LOW', 'MEDIUM', 'HIGH'],
                'MEDIUM': ['MEDIUM', 'HIGH'],
                'HIGH': ['HIGH']
              };
              
              // Get the threshold list
              const severityThresholds = severityLevels['${{ inputs.bandit-error-on-severity }}'] || ['LOW', 'MEDIUM', 'HIGH'];
              
              console.log(`Filtering for severities: ${severityThresholds.join(', ')}`);
              
              // Filter results based on severity level threshold
              let filtered_report = [];
              
              if (bandit_report.results) {
                filtered_report = bandit_report.results.filter(result => {
                  const severity = result.issue_severity.toUpperCase();
                  return severityThresholds.includes(severity);
                });
              }
              
              console.log(`Found ${filtered_report.length} Bandit issues meeting severity thresholds`);
              
              // Log the specific issues for visibility
              if (filtered_report.length > 0) {
                console.log("Found issues:");
                filtered_report.forEach((issue, idx) => {
                  const path = issue.filename;
                  const line = issue.line_number || 'N/A';
                  const message = issue.issue_text || 'No message provided';
                  const severity = issue.issue_severity.toUpperCase();
                  const confidence = issue.issue_confidence.toUpperCase();
                  
                  console.log(`#${idx+1}: ${path}:${line} - ${message} (Severity: ${severity}, Confidence: ${confidence})`);
                });
              }
              
              fs.writeFileSync('bandit_filtered_report.json', JSON.stringify(filtered_report));
              
              return filtered_report.length > 0 ? 'true' : 'false';
            } catch (error) {
              console.log('Error processing Bandit report:', error);
              return 'false';
            }
      
      - name: Upload bandit raw JSON Report
        if: inputs.bandit-upload-json-report == true
        uses: actions/upload-artifact@v4
        with:
          name: bandit_raw_report
          path: bandit_report.json
      
      - name: Upload bandit filtered JSON Report
        if: steps.bandit-filter.outputs.result == 'true' && inputs.bandit-upload-json-report == true
        uses: actions/upload-artifact@v4
        with:
          name: bandit_filtered_report
          path: bandit_filtered_report.json
      
      - name: Error if Bandit Scan Results
        if: steps.bandit-filter.outputs.result == 'true'
        shell: bash
        run: exit 1  
